@startuml Sequence-Contact-CineManga@startuml Séquence Contact - CinéManga

!theme aws-orange

title Séquence de Contact - CinéManga!theme aws-orange

title Diagramme de Séquence - Système de Contact

actor "Visiteur/\nUtilisateur" as user
participant "Frontend\n(React)" as frontend
participant "API Gateway\n(Nginx)" as NG
participant "React\nContactPage" as CP
participant "ContactController" as contact
participant "EntityManager" as EM
participant "ContactsRepository" as repo

participant "ContactsRepository" as CRparticipant "Database\n(MySQL)" as db

participant "Base de Données" as DBparticipant "Système de\nFichiers" as fs

participant "Système de Fichiers" as FS

user -> frontend : Remplit formulaire contact\n(nom, email, sujet, message)

' === ENVOI MESSAGE CONTACT ===frontend -> frontend : Validation côté client

V -> CP: Remplit formulaire contactfrontend -> contact : POST /contact/create\n{name, email, subject, message}

activate CP

note right of V: name, email, subject, messageactivate contact

contact -> contact : Décode données JSON

CP -> CP: Validation côté clientcontact -> contact : Extraction des champs\n+ validation présence

note right: Champs obligatoires\nFormat email

alt Tous les champs présents

CP -> NG: POST /contact/create\n{name, email, subject, message}    ' Création de l'objet contact

activate NG    contact -> contact : new Contacts()

note right: Pas d'authentification requise\nAccès public    contact -> contact : setName(name)

    contact -> contact : setEmail(email)

NG -> CC: createContact(Request)    contact -> contact : setSubject(subject)

activate CC    contact -> contact : setMessage(message)

    contact -> contact : setCreatedAt(new DateTimeImmutable())

CC -> CC: json_decode(request.getContent())    contact -> contact : setStatus(true) // Non lu

    

CC -> CC: Extraction des données    ' Sauvegarde en base

note right: name = data['name']\nemail = data['email']\nsubject = data['subject']\nmessage = data['message']    contact -> repo : persist(contact)

    contact -> repo : flush()

CC -> CC: Validation serveur    repo -> db : INSERT INTO contacts...

note right: empty() sur tous les champs\ncreatedAt = DateTimeImmutable('now')\nstatus = true (actif)    activate db

    db --> repo : ID généré

alt Tous les champs sont remplis    deactivate db

    CC -> CC: new Contacts()    

        ' Écriture notification dans fichier log

    CC -> CC: Initialisation objet    contact -> contact : Construction chemin log\n($_SERVER['DOCUMENT_ROOT']/../notifications.log)

    note right: setName(name)\nsetEmail(email)\nsetSubject(subject)\nsetMessage(message)\nsetCreatedAt(createdAt)\nsetStatus(true)    contact -> contact : Construction message log\n("Nouveau message de {name} à {datetime}")

        contact -> fs : file_put_contents(filePath, logMessage, FILE_APPEND)

    CC -> EM: persist(contact) + flush()    activate fs

    activate EM    fs --> contact : Écriture réussie

        deactivate fs

    EM -> DB: INSERT INTO contacts\n(name, email, subject, message, created_at, status)\nVALUES (?, ?, ?, ?, ?, ?)    

    activate DB    contact --> frontend : JsonResponse\n{status: 'Contact créé!'}

        frontend -> frontend : Affichage confirmation\n+ reset formulaire

    DB --> EM: Insertion réussie    frontend --> user : Message envoyé avec succès

    deactivate DB    

    else Champs manquants

    EM --> CC: Contact sauvegardé    contact --> frontend : JsonResponse\n{status: 'error',\n message: 'Tous les champs sont requis'}

    deactivate EM    frontend --> user : Erreurs validation

    end

    ' === GÉNÉRATION NOTIFICATION ===

    CC -> CC: Préparation notificationdeactivate contact

    note right: racine = $_SERVER['DOCUMENT_ROOT']\nracine = str_replace('public', '', racine)\nfilePath = racine . 'notifications.log'

    ' Processus de notification admin (asynchrone)

    CC -> CC: Création message lognote over fs

    note right: logMessage = "Nouveau message de {name} à " . date('Y-m-d H:i:s')  Le fichier notifications.log permet

      à l'administrateur de surveiller

    CC -> FS: file_put_contents(filePath, logMessage, FILE_APPEND)  les nouveaux messages sans

    activate FS  interroger constamment la base

    end note

    FS --> CC: Notification écrite

    deactivate FSnote right of contact

      Le statut true signifie "non lu"

    CC --> NG: JsonResponse({status: 'Contact créé!'}, 201)  L'admin pourra marquer comme lu

    deactivate CC  via l'interface d'administration

    end note

    NG --> CP: 201 Created - Message envoyé

    deactivate NGnote right of repo

      La date de création est automatiquement

    CP -> CP: Affichage confirmation  définie au moment de l'envoi pour

    CP -> CP: Réinitialisation formulaire  un suivi chronologique des messages

    end note

    CP --> V: "Message envoyé avec succès!"

    deactivate CP@enduml

    
else Champs manquants
    CC --> NG: JsonResponse({error: 'Tous les champs sont requis'}, 400)
    NG --> CP: 400 Bad Request
    CP --> V: Message d'erreur validation
end

' === CONSULTATION ADMIN (OPTIONNELLE) ===
note over V, FS: Le message est disponible pour consultation\ndans l'interface d'administration\net génère une notification dans notifications.log

' === SECOND ACTEUR - ADMIN ===
actor Administrateur as A
participant "React\nAdminPage" as AP

A -> AP: Consulte messages contact
activate AP

AP -> NG: GET /admin/board (inclut contacts)
activate NG

NG -> CC: Via AdminController.dashboard()
note right: Récupère tous les contacts\navec le reste des données

CC --> NG: Données contacts
NG --> AP: Liste des messages
deactivate NG

AP -> AP: Affichage des contacts
note right: Tri par date\nMarquage lu/non lu

AP --> A: Interface de gestion contacts
deactivate AP

' === NOTES ===
note over V, FS: Système de contact indépendant\nPas d'authentification requise\nNotification automatique pour admin

@enduml