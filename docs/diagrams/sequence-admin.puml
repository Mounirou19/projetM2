@startuml Sequence-Admin-CineManga@startuml Séquence Administration - CinéManga

!theme aws-orange

title Séquence d'Administration - CinéManga!theme aws-orange

title Diagramme de Séquence - Création de Média par Admin

actor "Administrateur" as admin
participant "Frontend\n(React)" as frontend
participant "API Gateway\n(Nginx)" as NG
participant "React\nAdminPage" as AP
participant "AdminController" as adminCtrl
participant "EntityManager" as EM
participant "MediasRepository" as mediaRepo

participant "MediasRepository" as MRparticipant "Database\n(MySQL)" as db

participant "Base de Données" as DB

admin -> frontend : Accède à "Créer un média"

' === ACCÈS TABLEAU DE BORD ===frontend -> frontend : Vérification token admin local

A -> AP: Accède à /adminfrontend -> adminCtrl : POST /admin/media/create\n+ headers X-ADMIN-TOKEN\n+ query params (role, token)\n+ body {title, description, type, imageUrl}

activate AP

activate adminCtrl

AP -> NG: GET /admin/board?infos=ROLE_ADMIN,adminToken\nX-ADMIN-TOKEN: envToken\nAuthorization: Bearer JWT

activate NG' Double vérification d'autorisation

adminCtrl -> adminCtrl : isAuthorized(request)\nvérification X-ADMIN-TOKEN

NG -> AC: dashboard(Request)adminCtrl -> adminCtrl : Extraction query params\n(role, token)

activate ACadminCtrl -> adminCtrl : Vérification ROLE_ADMIN\net token spécial



AC -> AC: isAuthorized(Request)alt Autorisations valides

note right: Vérification X-ADMIN-TOKEN\ncontre $_ENV['ADMIN_ACCESS_TOKEN']    adminCtrl -> adminCtrl : Décode données JSON

    

alt Token Admin valide    ' Vérification unicité du titre

    AC -> AC: Validation paramètres infos    adminCtrl -> mediaRepo : findOneBy(['title' => title])

    note right: ROLE_ADMIN + adminToken\n'd@t@ventureprojetM2123$'    activate mediaRepo

        mediaRepo -> db : SELECT * FROM medias\nWHERE title = ?

    alt Paramètres valides    activate db

        AC -> EM: getRepository(Users::class).findAll()    db --> mediaRepo : Media existant ou null

        activate EM    deactivate db

            mediaRepo --> adminCtrl : Media entity ou null

        EM -> DB: SELECT * FROM users    deactivate mediaRepo

        activate DB    

            alt Titre disponible

        DB --> EM: Tous les utilisateurs        ' Création du média

        deactivate DB        adminCtrl -> adminCtrl : new Medias()

                adminCtrl -> adminCtrl : setTitle(data['title'])

        EM --> AC: Liste utilisateurs        adminCtrl -> adminCtrl : setDescription(data['description'])

        deactivate EM        adminCtrl -> adminCtrl : setType(data['type'])

                adminCtrl -> adminCtrl : setImageUrl(data['imageUrl'])

        AC -> EM: getRepository(Medias::class).findAll()        adminCtrl -> adminCtrl : setStatus(true)

        activate EM        adminCtrl -> adminCtrl : setScore(0)

                

        EM -> DB: SELECT * FROM medias        ' Sauvegarde

        activate DB        adminCtrl -> mediaRepo : persist(media)

                adminCtrl -> mediaRepo : flush()

        DB --> EM: Tous les médias        mediaRepo -> db : INSERT INTO medias...

        deactivate DB        activate db

                db --> mediaRepo : ID généré

        EM --> AC: Liste médias        deactivate db

        deactivate EM        

                adminCtrl --> frontend : JsonResponse\n{status: 'success',\n message: 'Média créé'}

        AC -> EM: getRepository(Profils::class).findAll()        frontend -> frontend : Mise à jour liste\nou redirection

        activate EM        frontend --> admin : Confirmation création

                

        EM -> DB: SELECT * FROM profils    else Titre déjà existant

        activate DB        adminCtrl --> frontend : JsonResponse\n{status: 'error',\n message: 'Média déjà existant'}

                frontend --> admin : Erreur titre existant

        DB --> EM: Toutes les relations    end

        deactivate DB    

        else Autorisations invalides

        EM --> AC: Liste profils    adminCtrl --> frontend : JsonResponse\n{status: 'error',\n message: 'Accès interdit'}

        deactivate EM    frontend --> admin : Erreur d'autorisation

        end

        AC -> EM: getRepository(Contacts::class).findAll()

        activate EMdeactivate adminCtrl

        

        EM -> DB: SELECT * FROM contactsnote right of adminCtrl

        activate DB  Triple vérification d'autorisation :

          1. Token dans header X-ADMIN-TOKEN

        DB --> EM: Tous les contacts  2. Rôle ROLE_ADMIN dans query params

        deactivate DB  3. Token spécial d'administration

          

        EM --> AC: Liste contacts  Cette approche, bien que redondante,

        deactivate EM  assure une sécurité maximale pour

          les opérations d'administration.

        AC -> AC: Formatage données pour JSONend note

        note right: Structure hiérarchique\nusers, medias, profils, contacts

        note right of mediaRepo

        AC --> NG: JsonResponse({status: success, data: {...}}, 200)  Le score est initialisé à 0

        deactivate AC  lors de la création et sera

          mis à jour par les notations

        NG --> AP: 200 OK + Données complètes  des utilisateurs.

        deactivate NGend note

        

        AP -> AP: Affichage tableau de bord@enduml

        AP --> A: Interface d'administration
        deactivate AP
        
    else Paramètres invalides
        AC --> NG: JsonResponse({error: 'Accès interdit'}, 403)
        NG --> AP: 403 Forbidden
        AP --> A: Redirection connexion
    end
    
else Token Admin invalide
    AC --> NG: JsonResponse({error: 'Accès interdit'}, 403)
    NG --> AP: 403 Forbidden
    AP --> A: Redirection connexion
end

' === CRÉATION D'UN MÉDIA ===
A -> AP: Remplit formulaire création média
activate AP

AP -> NG: POST /admin/media/create?infos=ROLE_ADMIN,adminToken\nX-ADMIN-TOKEN: envToken\n{title, type, imageUrl, description, score}
activate NG

NG -> AC: createMedia(Request)
activate AC

AC -> AC: Double vérification sécurité
note right: isAuthorized() + paramètres

AC -> AC: json_decode(request.getContent())

AC -> EM: getRepository(Medias::class)
activate EM

EM -> MR: findOneBy(['title' => title])
activate MR

MR -> DB: SELECT * FROM medias WHERE title = ?
activate DB

alt Média avec même titre existe
    DB --> MR: Média trouvé
    deactivate DB
    
    MR --> EM: Média existant
    deactivate MR
    
    EM --> AC: Conflit titre
    deactivate EM
    
    AC --> NG: JsonResponse({error: 'Média déjà existant'}, 400)
    NG --> AP: 400 Bad Request
    AP --> A: Message d'erreur
    
else Titre unique
    DB --> MR: Aucun résultat
    MR --> EM: null
    EM --> AC: Titre disponible
    
    AC -> AC: new Medias()\nsetTitle(), setType(), etc.\nsetStatus(true)
    
    AC -> EM: persist(media) + flush()
    activate EM
    
    EM -> DB: INSERT INTO medias (...) VALUES (...)
    activate DB
    
    DB --> EM: Insertion réussie
    deactivate DB
    
    EM --> AC: Média créé
    deactivate EM
    
    AC --> NG: JsonResponse({status: success, message: 'Média créé'}, 200)
    deactivate AC
    
    NG --> AP: 200 OK - Création réussie
    deactivate NG
    
    AP -> AP: Rafraîchissement liste médias
    AP --> A: Confirmation création
    deactivate AP
end

' === NOTES ===
note over A, DB: Double authentification admin\nToken HTTP + Paramètres URL\nValidation métier (unicité titre)

@enduml